@page "/requestresults"
@using hello_rusy.Data
@using Microsoft.AspNetCore.WebUtilities

@inject IConfiguration Configuration
@inject NavigationManager Navigation
@inject VideoIndexerService videoIndexerServiceInstance
@inject LanguageAIService languageAIServiceInstance
@inject OpenAIService openAIServiceInstance
@inject VideoMetadataService videoMetadataServiceInstance


@inject IJSRuntime JS
@*<link href="styles.css" rel="stylesheet" />*@

<h1>@summarizedTitle</h1>
@*<style>
        #myVideoPlayer {
            width: 30%; /* Adjust the width to your preference */
            margin: auto; /* This centers the video player horizontally */
            display: block; /* Ensures the margin auto has the desired effect */
        }
    </style>*@

@if (responseReceived)
{
    @*<p>Chat Result: @openAIResult</p>*@
    <h2>Tasks</h2>
    <div style="display: flex; flex-wrap: wrap; gap: 20px;">
        <div style="flex: 3; min-width: 300px;">

            <ol>
                @foreach (var todo in todos.ToDos)
                {
                    <li>
                        <button class="btn-primary" @onclick="() => SeekTo(todo.Timestamp)">&#9205;</button>
                        @todo.Task
                    </li>
                }
            </ol>
        </div>

        <div style="flex: 2; min-width: 300px; max-width: 600px;">
            <video id="myVideoPlayer" controls @ref="videoElement" preload="auto" style="width: 100%;">
                <source src="@videoUrl" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            @code {
                private ElementReference videoElement; // Reference to the video element
                public string videoUrl; // URL of the video to play

                // Call JavaScript to attach event listeners once the video element is available
                protected override async Task OnAfterRenderAsync(bool firstRender)
                {
                    if (firstRender)
                    {
                        // Ensure the video URL is set before invoking JavaScript
                        if (!string.IsNullOrEmpty(videoUrl))
                        {
                            await JS.InvokeVoidAsync("eval", "alert('is not null or empty from Blazor');");
                            await JS.InvokeVoidAsync("setupVideoTimestampFeedback");
                        } else
                        {
                            await JS.InvokeVoidAsync("eval", "alert('is null or empty from Blazor');");
                            await JS.InvokeVoidAsync("setupVideoTimestampFeedback");
                        }
                    }
                }

                // Example function to set video source dynamically and ensure JS is called
                private async Task UpdateVideoSource(string newVideoUrl)
                {
                    videoUrl = newVideoUrl;
                    // You might need to invoke the JS function here too if the video source can change after the initial render
                    await JS.InvokeVoidAsync("timestampTaskFeedback");
                }
            }

        </div>
    </div>
    <h2>Key Words</h2>
    <div class="chunk">
        <p>@string.Join(", ", keywords)</p>
    </div>

    <h2>Transcripts</h2>
    <div class="chunk">
        <p>
            @foreach (var t in transcripts)
            {
                @t <br>
            }
        </p>
    </div>

}
else
{

    <div>
        <label for="videoId">Video Name:</label>
        <input id="videoId" type="text" @bind="videoId" />
    </div>

    <button @onclick="Submit">Submit</button>
}

@code {
    private string videoId;


    private VideoIndexerResult videoInformation;
    private string fileName;
    private string state;
    private List<string> transcripts;
    private List<string> transcriptTimes;
    private List<List<string>> keyframeUrls;


    private List<string> keywords;
    private string keywordsString;

    private bool responseReceived = false;

    private TextSummarizerResult textSummaryResult;

    private string summarizedTitle;

    private string openAIResult;
    private ToDoList todos;

    //private ElementReference videoElement;
    //public string videoUrl;

    private EgocentricVideoConfig config;

    protected override async Task OnInitializedAsync()
    {
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);

        // Check if there's a query string parameter for the video ID
        if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("videoId", out var videoIds))
        {
            videoId = videoIds.First(); // Assuming you're passing a single ID
            await Submit(); // Automatically fetch and display the results

        }

    }

    private async Task Submit()
    {
        config = new EgocentricVideoConfig(
            videoIndexerApiKey: Configuration["VideoIndexer:AccessToken"],
            videoIndexerAccountId: Configuration["VideoIndexer:AccountId"],
            videoIndexerLocation: Configuration["VideoIndexer:Location"],
            videoIndexerSubscriptionKey: Configuration["VideoIndexer:SubscriptionKey"],
            dataFileConnectionString: Configuration?["AzureBlobStorageDataFiles:ConnectionString"] ?? "",
            dataFileContainerName: Configuration?["AzureBlobStorageDataFiles:ContainerName"] ?? "",
            openAIApiKey: Configuration?["OpenAI:APIKey"] ?? "",
            languageServiceApiKey: Configuration?["LanguageAI:SubscriptionKey"] ?? ""
        );
        VideoMetadataController videoMetadataControllerInstance = new VideoMetadataController(videoIndexerServiceInstance, openAIServiceInstance, videoMetadataServiceInstance, languageAIServiceInstance);
        VideoMetadata videoMetadata = await videoMetadataControllerInstance.RetrieveGeneralMetadata(videoId, config);
        videoUrl = videoMetadata.VideoUrl; // TODO: PROBABLY NOT SECURE
        summarizedTitle = videoMetadata.SummarizedTitle;
        //dateProcessed = videoMetadata.ProcessedDate;
        todos = await videoMetadataControllerInstance.RetrieveOpenAIMetadata(videoId, config);
        VideoIndexerMetadata videoIndexerMetadata = await videoMetadataControllerInstance.RetrieveVideoIndexerMetadata(videoId, config);
        keyframeUrls = videoIndexerMetadata.KeyframeShots;

        transcripts = videoIndexerMetadata.Transcripts;

        keywords = videoIndexerMetadata.Keywords;

        responseReceived = true;

        // TODO: run custom javascript 
        //await timestampFeedback();

    }


    private async Task OnMetadataLoaded()
    {
        await JS.InvokeVoidAsync("timestampTaskFeedback");
        //await JS.InvokeVoidAsync("eval", $"document.getElementById('myVideoPlayer').currentTime = {StartTime};");
    }

    private async Task SeekTo(string timestamp)
    {
        int timestampDouble = ConvertTimeToSeconds(timestamp);
        //StartTime = timestampDouble;
        Console.WriteLine("TIMESTAMP: " + timestampDouble);
        await JS.InvokeVoidAsync("setVideoCurrentTime", "myVideoPlayer", timestampDouble.ToString());
        //await JS.InvokeVoidAsync("eval", $"document.getElementById('myVideoPlayer').currentTime = {timestampDouble.ToString()};");
    }

    private async Task timestampFeedback()
    {
        //await JSRuntime.InvokeVoidAsync("timestampTaskFeedback");
        await JS.InvokeVoidAsync("timestampTaskFeedback");

    }

    public static int ConvertTimeToSeconds(string time)
    {
        double totalSeconds = 0;
        if (TimeSpan.TryParse(time, out TimeSpan result))
        {
            totalSeconds = result.TotalSeconds;
        }

        return (int)totalSeconds;
    }
}